# ysoftman
# -*- coding: utf-8 -*-
'''
과자를 좋아하는 동우는 책상 위에 일렬로 놓아진 과자를 발견하였습니다.
과자에는 맛을 숫자로 평가한 종이가 붙어 있습니다.
동우는 맨 왼쪽부터 순서대로 과자를 먹기로 하였습니다.
동우는 먹을 과자를 고를 때 이전에 먹은 과자보다 맛이 더 좋은 과자만 먹습니다.
제일 처음에 맛이 3인 과자를 먹었다면, 다음에는 4보다 작은 맛의 과자는 먹지 않습니다.
책상위에 놓인 과자의 맛이 입력되면, 동우가 최대 과자를 몇 개를 먹을 수 있는지 반환해주는 eatCookie 함수를 완성하세요.
예를 들어 [1, 4, 2, 6, 3, 4, 1, 5] 가 입력된다면
동우는 1, 3, 5, 6, 8번째 과자(각각의 맛은 1, 2, 3, 4, 5)를 골라 총 5개를 먹을 수 있고,
5개보다 더 많이 먹을 수 있는 방법은 없으므로 5를 리턴하면 됩니다.
'''

'''
뒤부터 각 위치에서 먹을 수 있는 과자를 카운트하는 리스트를 만든다.
현재 위치를 기준으로 뒤에 오는 원소들 중 현재 위치의 값 보다 큰 원소들 중 가장 큰 카운트를 더한다.
1, 4, 2, 6, 3, 4, 1, 5 의 경우
[1, 1, 1, 1, 1, 1, 1, 1] 
[1, 1, 1, 1, 1, 1, 2, 1] 
[1, 1, 1, 1, 1, 2, 2, 1] 
[1, 1, 1, 1, 3, 2, 2, 1] 
[1, 1, 1, 1, 3, 2, 2, 1]
[1, 1, 4, 1, 3, 2, 2, 1]
[1, 2, 4, 1, 3, 2, 2, 1]
[5, 2, 4, 1, 3, 2, 2, 1]
카운트 리스의 값 중 가장 큰것 5 가 최대경우의 수가 된다.
'''


def eatCookie(cookies):
    bigcnt = []
    for i in range(len(cookies)):
        bigcnt.append(1)

    for i in range(len(cookies) - 1, -1, -1):
        temp = 0
        for j in range(i + 1, len(cookies)):
            if cookies[j] > cookies[i]:
                if temp < bigcnt[j]:
                    temp = bigcnt[j]
        bigcnt[i] += temp
        # print bigcnt

    return max(bigcnt)


# 아래는 테스트로 출력해 보기 위한 코드입니다.
print(eatCookie([1, 4, 2, 6, 3, 4, 1, 5]))
# print(eatCookie([284, 6, 41, 812, 443, 524, 558, 4, 630, 458, 32, 783, 169, 421, 115, 837, 488, 954, 800, 192, 848, 600, 259, 710, 338,
#                  482, 709, 68, 387, 187, 701, 759, 464, 386, 902, 891, 590, 824, 781, 190, 816, 511, 93, 690, 241, 562, 801, 378, 555, 583]))  # 11
